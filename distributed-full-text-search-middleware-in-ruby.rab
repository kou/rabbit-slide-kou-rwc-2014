= Rubyを使った\n分散全文検索ミドルウェア

: author
   須藤功平
: institution
   株式会社クリアコード
: content-source
   RubyWorld Conference 2014
: date
   2014/11/13
: allotted-time
   30m
: theme
   .

= 趣意書 - 今

  * 今ではRubyは「当たり前」
  * Rubyはキャズム理論の段階を\n
    順当に進んできている
  * Rubyは「レートマジョリティ」\n
    にも到達しつつある
    * 「レートマジョリティ」 =\n
      「普通の人々」

= 趣意書 - これから

  * 「レートマジョリティ」に\n
    浸透させるには？
    * 技術だけを追求するのではなく、\n
      心理的、経済的、政治的な障害なども考慮する必要がある
  * Ruby普及における重要なテーマ
    * これらの障害を乗り越えた\n
      「浸透(penetration)」

= 趣意書 - まとめ

Rubyを\n
普通の人々に\n
浸透させたい！

= この発表の内容

浸透促進案の\n
ご提案

= 浸透の定義

Rubyを使っても\n
驚かない

= 普通の人々

  * IT系
    * いつもプログラムを書いている人
    * たまにプログラムを書く人
    * プログラムを使う人
  * 非IT系
    * こども

= 領域拡大な浸透方法

  * IT系
    * ((*いつもプログラムを書いている人*))
    * ((*たまにプログラムを書く人*))
    * プログラムを使う人
  * 非IT系
    * こども

= 新規開拓な浸透方法

  * IT系
    * いつもプログラムを書いている人
    * たまにプログラムを書く人
    * ((*プログラムを使う人*))
  * 非IT系
    * ((*こども*))

= 提案方針

  * 領域拡大にフォーカス
  * 新規開拓は考えない
    * おんがえしさんのofrubyは\n
      1つのやり方のように思える

= 領域拡大

  * 他の言語からの移行を促す
  * 技術的な攻め方
    * 多機能・高機能・高性能
  * 心理的・政治的な攻め方
    * 流行り(('note:（「みんな」使っていますよ）'))

= 領域拡大 - 提案方針

  * 他の言語からの移行を促す
  * 技術的な攻め方
    * 多機能・高機能・高性能
  * 心理的・政治的な攻め方
    * ((*流行り*))(('note:（「みんな」使っていますよ）'))

= 流行っている状態

(('tag:center'))シェアを独占している

  * キラーアプリがある
    * 例：Ruby on Rails
  * 有用アプリの多くがRuby製
    * 例：Chef, Puppet, Vagrant, Serverspec

= キラーアプリは難しい

(('tag:center'))シェアを独占している

  * (('del:キラーアプリがある'))
    * 例：Ruby on Rails
  * 有用アプリの多くがRuby製
    * 例：Chef, Puppet, Vagrant, Serverspec

= 多有用アプリ状況を目指す

  * Ruby製アプリを作る
    * そこそこ有用で十分
    * たくさん作る
  * Ruby製アプリ使う
    * Ruby製アプリを優先して選ぶ
    * 使っていることを広くアピール

= Ruby製アプリ作りを支援

  * 成功事例
    * 後続が真似したくなればよい
    * そんなに流行らなくてもよい
  * 開発ノウハウ
    * 後続が開発しやすくなる
    * ライブラリー化されていると尚よし

= 領域拡大の対象分野案

ミドルウェア\n
↓\n
アプリは\n
好きな言語で書ける\n
(('note:（採用障壁が低め）'))\n
(('note:（例：RabbitMQはErlang製だがアプリはErlang以外が多い）'))

= ミドルウェア

  * データストア（RDBMSやKVS）
  * 検索システム
  * メッセージキュー
  * ログ活用（分析や監視）

= Rubyでミドルウェア

  * 成功事例
    * Fluentd
    * 分散全文検索エンジンを開発中\n
      (('note:（Droonga）'))
  * 開発ノウハウ
    * これから紹介

= 開発ノウハウ

  * トレードオフと向き合う
  * 全方位で勝つことはできない
    * Rubyだって速さじゃCに勝てない
    * でも楽しさならCに勝てる

= 強みの選び方

  * 最高速で勝負しない
  * 多機能で勝負しない
  * 使いやすさで勝負する

= 性能

  * 最高速は目指さない
    * C/C++とかJavaに負ける
  * 十分な速度は目指す
    * ミドルウェアが\n
      ボトルネックにならない程度

= 高速化方法

  * ボトルネックを確認！
  * ボトルネックになりやすい箇所
    * CPU
    * ネットワーク
  * なるかもしれない箇所
    * I/Oとメモリー

= CPUネック

  * ((*処理を減らす*))
  * マルチプロセス
    * 後述
  * Cで拡張ライブラリーを書く
    * Fluentd: MessagePack
    * Droonga: MessagePack, Groonga

= マルチプロセス実装

  * ServerEngine（ライブラリー）
    * nスレッド+シグナル+fork(('note:(spawn)'))
  * Droonga
    * 1スレッド+パイプ+spawn(('note: +イベントループ'))
    * ↑の方がオススメ

= ServerEngine

  # image
  # src = images/serverengine-model.svg
  # relative_height = 100

== スライドプロパティー

: enable-title-on-image
   false

= ServerEngineモデル1

  * 基本はSupervisor→Worker
    * ハートビートは例外
  * gracefulな再起動をしにくい
    * 新Workerがいつ準備完了したか\n
      わからない
    * Worker→Supervisorがない

= ServerEngineモデル2

  * スレッドは難しい
    * エラーに気づいている？
    * rescueしてる？joinしてる？
  * シグナルは難しい
    * 終了中に何度でもSIGINT
    * 終了フラグを立てるくらいしか\n
      できない

= ServerEngineモデル3

  * ライブラリー化していてえらい

= Droongaモデル1

  * 通信はSupervisor↔Worker
  * gracefulな再起動をしやすい
    * 新Workerが準備完了\n
      →Supervisorに通知\n
      →旧Workerをgracefulに終了

= Droongaモデル2

  * シンプルになる
    * 1スレッド・シグナルなし
    * stop中にn回stopがこない
    * 終了処理中に割り込まれない
  * イベント駆動は複雑

= ネットワークネック

  * ノンブロッキングI/Oと多重化
    * 拡張ライブラリー必須
    * →Cool.io, nio4r, EventMachine
    * イベント駆動なコードは複雑
  * 通信量を減らす
    * ((*データを減らす*))
    * ムリなら圧縮（zlib, LZ4）

= イベント駆動なコード

  # coderay ruby

  Coolio::TCPServer.new(HOST, PORT) do |client|
    n_reads = 0
    client.on_read do |data|
      p data
      client.write(data)
      n_reads += 1
      if n_reads == 2
        client.on_write_complete {client.close}
      end
    end
  end

= 同期っぽく書けるAPI

  # coderay ruby

  Coolio::TCPServer.new(HOST, PORT) do |client|
    Fiber.run do # <- 並行にしたい処理を明示
      client.extend(Synchronizable) # <- 42行
      2.times do
        data = client.read
        p data
        client.write(data)
      end
      client.close
    end
  end

= 同期っぽく書けるAPI

  * ユーザーがFiberを書くのが\n
    カッコ悪い
  * いつでもFiberで囲めるのか？
  * 同期っぽい中で\n
    並行に処理したくなったら？

= Promiseな世界

  # coderay ruby

  server.accept.then do |client|
    client.read.then do |data|
      p data
      client.write(data)
    end.then do
      client.close
    end
  end.catch do |error|
  end

= Promiseな世界

  * 繰り返しを書きにくい
  * メソッドチェーンがカッコ悪い
  * catchがカッコ悪い

= API案：基本

  # coderay ruby

  # 同期っぽいAPI
  clinet = server.accept
  # 非同期API
  server.accept do |request|
    begin
      client = request.socket
    rescue
    end
  end

= API案：組み合わせ

  # coderay ruby

  server.accept do |request|
    client = request.socket
    2.times do
      data = client.read
      p data
      client.write(data)
    end
    client.close
  end

= API案

  * Fiberが見えない
  * 書き方の組み合わせが自然
    * ブロックなし→同期っぽいAPI
    * ブロックあり→非同期API
  * 実装していない😜

= I/Oとメモリーネック

  * データストアをCで書く
    * Droonga: Groonga
    * ROMA: Tokyo Cabinet, SQLite3
  * コアの機能もCで書く
    * データコピーも減らしたいとき

= 強みの選び方 - 性能

  * 最高速で勝負しない
    * でも、十分な速度は目指す
    * ボトルネックにならなければよい
  * 多機能で勝負しない
  * 使いやすさで勝負する

= 機能

  * 多機能をウリにしない
    * 多機能だと遅くなる(('note:ことが多い'))
  * 組み込みの機能より拡張性
    * →プラグイン機能
    * Fluentd, ROMA, Droonga

= プラグイン機能のポイント

  * 開発者向け
    * 作りやすい
    * テストしやすい
    * リリースしやすい
  * ユーザー向け
    * インストールしやすい
    * 設定しやすい

= 開発者向け

  * 作りやすさ
    * scaffoldいらずのAPI
  * テストしやすさ
    * ドライバー・スタブを提供
  * リリースしやすさ
    * gem, GitHubから直接

= ユーザー向け

  * インストールのしやすさ
    * Rubyをそんなに知らない前提なのに\n
      直接gemを使ってもらうのってアリ？
  * 設定のしやすさ
    * できるだけ少なく
    * できればno configuration

= 強みの選び方 - 機能

  * 最高速で勝負しない
  * 多機能で勝負しない
    * 組込機能よりも簡単拡張で勝負
    * Ruby初心者でも開発できる簡単さ
    * →プラグイン開発でRubyデビュー\n
      (('note:（tDiaryスタイルのRuby浸透方法）'))
  * 使いやすさで勝負する

= 使いやすさ1

  * 設定は少ないほうがよい
    * 適切なデフォルト値
    * 自動調整
    * 起動後に設定
  * 起動するだけなら設定なしで
    * 起動するまでが一番くじけやすい

= 使いやすさ2

  * セットアップなしにする
    * サービスとしても提供
    * →登録したらすぐ使える
    * →管理もしなくてよい
    * →ローカルでテストしにくい

= まとめ1

  * 趣意書
    * Rubyを浸透させたい！
  * この発表
    * 浸透促進案の提案
    * ミドルウェア分野での促進案

= まとめ2：促進案

  * たくさん作る
    * ノウハウを広める
  * たくさんの人が使う
    * 他の方がよさそうでも\n
      Ruby製を優先して使う
    * 使っていることを広める

= まとめ3：作るノウハウ

  * 最高速で勝負しない
  * 多機能で勝負しない
  * 使いやすさで勝負する

= おまけ

Droongaの紹介

= Droongaとは

  * Ruby製
  * 分散全文検索エンジン
  * SPOFなしの構成

= Droongaの特徴

  * 処理をパイプラインとして\n
    つなげられる(('note:予定'))
  * 処理はプラグイン可能
    * Rubyで簡単に(('note:（予定）'))書ける
  * Groonga互換API提供
    * Groonga = 既存検索エンジン

= Droongaの実装：性能

  * レイテンシー
    * Groongaより高いけど\n
      気になるほどではない
  * スループット
    * ノード数を増やせばGroongaより速い

= Droongaの実装：機能

  * プラグインで拡張可能
  * プラグイン例
    * Groonga互換API
  * プラグインの作りやすさ
    * これからがんばる

= Droongaの実装：使いやすさ

  * インストール
    * インストーラー提供で簡易化
  * 設定
    * 自動設定化を進めている
  * 更新時・運用時
    * これからがんばる

= Droonga

http://droonga.org/\n
\n
11/29（いい肉の日）\n
Groongaイベント開催(('note:（東京）'))\n
(('note:http://groonga.doorkeeper.jp/events/15816'))
